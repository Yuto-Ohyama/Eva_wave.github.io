<!DOCTYPE html>
<html>
<head>
  <title>Pythonで残酷な天使のテーゼを奏でる</title>
  <meta charset="UTF-8">
</head>
<body>
  <h1>Pythonで残酷な天使のテーゼを奏でる</h1>
  <p>参照したサイトはこちら</p>
  <a href="https://qiita.com/TatchNicolas/items/fb4064a7f394b977765e">「Numpyで奏でるクリスマスソング」</a>
<!--これはコメントアウト-->
  <ol>
  <li>とりあえず音を鳴らしてみる</li>
  </ol>
  <pre>
    import numpy as np
    import IPython.display 

    BIT_RATE = 44100
    concert_pitch = 220

    A3 = concert_pitch 

        # ピアノでいう、いわゆる「ラ」の音
  </pre>

  <pre>
    duration = 3
    sample_A3 = np.sin(A3 * 2 * np.pi * np.linspace(0, duration, duration * BIT_RATE))
    IPython.display.Audio(sample_A3, rate=BIT_RATE)


        ratios = [2 ** (i / 12) for i in range(0, 13)]
        tone_names = ['A3', 'As3', 'B3', 'C4', 'Cs4', 'D4', 'Ds4', 'E4', 'F4', 'Fs4', 'G4', 'Gs4','A4' ]

        TONE_DICT = {}

            # A3からA4のクロマチックスケール
  </pre>
    
  <pre>
      for ratio, tone_name in zip(ratios, tone_names):
            duration = 1
            frequency = ratio * A3
            tmp_sound = np.sin(frequency * 2 * np.pi * np.linspace(0, duration, duration * BIT_RATE))
            audio=IPython.display.Audio(tmp_sound, rate=BIT_RATE)

            # あとで使えるように辞書に周波数を入れとく
        TONE_DICT[tone_name] = frequency
            # Jupyter上に表示
            print(f'tone_name:{tone_name}, frequency: {frequency}')
            IPython.display.display(audio)

            # 1オクターブ上、1オクターブ下、2 オクターブ下も作る
  </pre>
  <ol>
    <il>さきほどの1オクターブ分の周波数を作る処理を関数化</il>
  </ol>

  <pre>
        def generate_octave(start, tone_names):
            dict_to_return = {}
            for ratio, tone_name in zip(ratios, tone_names):
                frequency = ratio * start
                dict_to_return[tone_name] = frequency
            return dict_to_return

            # A2からA3のクロマチックスケール

        tone_names_a2_a3 = [ 'A2', 'As2', 'B2', 'C3', 'Cs3', 'D3', 'Ds3', 'E3', 'F3', 'Fs3', 'G3', 'Gs3', 'A3']
        a2_a3 = generate_octave(TONE_DICT['A3'] / 2, tone_names_a2_a3)  # 基準音(440Hz)の半分の周波数 = 1オクターブ下の音から始める
        TONE_DICT.update(a2_a3)

            # A1からA2のクロマチックスケール

        tone_names_a1_a2 = [ 'A1', 'As1', 'B1','C2', 'Cs2', 'D2', 'Ds2', 'E2', 'F2', 'Fs2', 'G2', 'Gs2', 'A2']
        a1_a2 = generate_octave(TONE_DICT['A3'] / 4, tone_names_a1_a2)  # 基準音(440Hz)の1/4周波数 = 2オクターブ下の音から始める
        TONE_DICT.update(a1_a2)

            # A4からA5のクロマチックスケール

        tone_names_a4_a5 = [ 'A4', 'As4', 'B4','C5', 'Cs5', 'D5', 'Ds5', 'E5', 'F5', 'Fs5', 'G5', 'Gs5', 'A5']
        a4_a5 = generate_octave(TONE_DICT['A3'] * 2, tone_names_a4_a5)  # 基準音(440Hz)の4倍の周波数 = 2オクターブ上の音から始める
        TONE_DICT.update(a4_a5)
  </pre>
<ol>
  <il>音価(音の長さ)をつくる</il>
</ol>

<pre>
    QUATER = 1/2
    EIGHTH =  QUATER / 2
    SIXTEENTH =  EIGHTH / 2
</pre>

<ol>
  <il>周波数と音価からsin波として音を作る関数</il>
</ol>

<pre>
  def generate_note(frequency, note_value):
        one_sec_note = np.sin(TONE_DICT[frequency] * 2 * np.pi * np.linspace(0, 2, 2 * BIT_RATE))
        return one_sec_note[0:int(len(one_sec_note) * note_value)]
</pre>

<ol>
  <il>配列を結合する = 音を楽譜で横に並べる = メロディ</il>
</ol>

<pre>
    c3v4 = generate_note('C3', QUATER)
    d3v4 = generate_note('D3', QUATER)
    e3v4 = generate_note('E3', QUATER)
    f3v4 = generate_note('F3', QUATER)

    frog = np.hstack((c3v4, d3v4, e3v4, f3v4, e3v4, d3v4, c3v4))
    IPython.display.Audio(frog, rate=BIT_RATE)

</pre>

<ol>
  <il>配列の和 = 音を楽譜で縦に並べる = ハーモニー</il>
</ol>

<pre>
    c3v2 = generate_note('C3', QUATER * 2)
    e3v2 = generate_note('E3', QUATER * 2)
    g3v2 = generate_note('G3',QUATER * 2)

    c_triad_chord = np.vstack((c3v2, e3v2, g3v2))
    IPython.display.Audio(c_triad_chord, rate=BIT_RATE)
 
</pre>

<ol>
  <il>残酷な天使のテーゼ～エヴァンゲリオン～</il>
</ol>

<pre>
  
</pre>

<ol>
  <il>長さの関係で一旦区切る</il>
</ol>

<pre>
  
</pre>

<ol>
  <il>一応間奏も</il>
</ol>

<pre>
  
</pre>

<ol>
  <il>2番以降は繰り返しです</il>
</ol>

<pre>
  
</pre>

<ol>
  <il></il>
</ol>
</body>
</html>
